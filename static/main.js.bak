// Add a debug log helper - enhanced version
function mainLog(message, data = null) {
    const timestamp = new Date().toISOString();
    console.log(`[Main ${timestamp}] ${message}`, data || '');
}

// Global variables for event handling
let currentEventSource = null;
let processedMessageIds = new Set();
let connectionStatus = {
    connecting: false,
    connected: false
};

// Store visualization items
let outputItems = [];

// Debug counters for event source messages
let debugMsgCounter = {
    connected: 0,
    status: 0,
    step: 0,
    log: 0,
    think: 0,
    tool: 0,
    result: 0,
    act: 0
};

// Main application initialization
document.addEventListener('DOMContentLoaded', function() {
    mainLog('DOM content loaded, initializing application');
    
    // Setup UI components 
    setupUI();
    
    // Setup task creation capabilities
    setupTaskCreation();
    
    // Check user authentication and initialize
    checkAuthentication().then(() => {
        initializeActiveTask();
    }).catch(err => {
        mainLog('Authentication error:', err);
    });
});

// Function to load active task on page load (removed task history)
async function initializeActiveTask() {
    mainLog('Initializing active task');
    
    try {
        // Check for token validity first
        const isValid = await window.checkAndRefreshToken();
        if (!isValid) {
            mainLog('Token invalid, redirecting to login');
            window.location.href = '/login?session_expired=true';
            return;
        }
        
        // Get tasks from API
        const token = localStorage.getItem('auth_token');
        const response = await fetch('/tasks', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        
        if (response.status === 200) {
            const tasks = await response.json();
            
            // Check if we have any tasks
            if (tasks && tasks.length > 0) {
                // Sort by date, newest first
                tasks.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                // Get the most recent task
                const latestTask = tasks[0];
                
                // If the task is still running, connect to its event stream
                if (latestTask.status === 'running') {
                    mainLog('Found running task, connecting to SSE', latestTask);
                    setupSSE(latestTask.id);
                }
            }
        }
    } catch (error) {
        mainLog('Error initializing active task:', error);
    }
}

// Global task creation lock
window.TASK_LOCK = {
    isCreating: false,
    lastCreationTime: 0,
    pendingPrompt: null,
    
    // Acquire the lock
    acquire: function() {
        if (this.isCreating) {
            return false;
        }
        
        const now = Date.now();
        // Add a cooldown period to prevent rapid creation
        if (now - this.lastCreationTime < 3000) { // 3 seconds
            mainLog('Task creation prevented - too soon since last task');
            return false;
        }
        
        this.isCreating = true;
        return true;
    },
    
    // Release the lock
    release: function() {
        this.lastCreationTime = Date.now();
        this.isCreating = false;
    }
};

// Setup task creation handling - use capture phase to intercept events as early as possible
function setupTaskCreation() {
    mainLog('Setting up task creation handling with global lock system');
    
    // Intercept all submit events at the document level 
    document.addEventListener('submit', function(event) {
        if (event.target.id === 'prompt-form') {
            event.preventDefault();
            event.stopPropagation();
            handleTaskCreation();
            return false;
        }
    }, true); // Use capture phase
    
    // Handle key events at the document level in capture phase
    document.addEventListener('keydown', function(event) {
        const promptInput = document.getElementById('prompt-input');
        
        if (event.key === 'Enter' && 
            document.activeElement === promptInput && 
            !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey) {
                
            event.preventDefault();
            event.stopPropagation();
            handleTaskCreation();
            return false;
        }
    }, true); // Use capture phase
    
    // Handle click events at the document level in capture phase
    document.addEventListener('click', function(event) {
        const sendButton = document.querySelector('#prompt-input + button') || 
                           document.querySelector('.send-button');
                           
        if (event.target === sendButton || sendButton?.contains(event.target)) {
            event.preventDefault();
            event.stopPropagation();
            handleTaskCreation();
            return false;
        }
    }, true); // Use capture phase
    
    // Add form submit prevention just in case
    const form = document.querySelector('form');
    if (form) {
        form.onsubmit = function(e) {
            e.preventDefault();
            return false;
        };
    }
}

// Consolidated task creation handler
function handleTaskCreation() {
    // Don't proceed if lock can't be acquired
    if (!window.TASK_LOCK.acquire()) {
        mainLog('Task creation ignored - lock acquisition failed');
        return;
    }
    
    mainLog('Creating task - lock acquired');
    
    const promptInput = document.getElementById('prompt-input');
    const prompt = promptInput?.value?.trim() || '';
    
    if (!prompt) {
        window.TASK_LOCK.release();
        alert("Please enter a valid prompt");
        promptInput?.focus();
        return;
    }
    
    try {
        window.TASK_LOCK.pendingPrompt = prompt;
        
        // Store the prompt value for later
        const promptValue = prompt;
        
        // Clear the input right away to prevent duplicate submission
        if (promptInput) {
            promptInput.value = '';
            promptInput.disabled = true;
        }
        
        // Disable any send buttons
        const sendButton = document.querySelector('#prompt-input + button') || 
                           document.querySelector('.send-button');
        if (sendButton) {
            sendButton.disabled = true;
        }
        
        // Create the task with the stored prompt
        createTask(promptValue)
            .then(() => {
                mainLog('Task created successfully');
            })
            .catch(error => {
                mainLog('Task creation failed:', error);
                
                // Restore the input value on error
                if (promptInput) {
                    promptInput.value = window.TASK_LOCK.pendingPrompt || '';
                }
            })
            .finally(() => {
                // Re-enable controls
                if (promptInput) promptInput.disabled = false;
                if (sendButton) sendButton.disabled = false;
                
                // Release the lock with a short delay
                setTimeout(() => {
                    window.TASK_LOCK.pendingPrompt = null;
                    window.TASK_LOCK.release();
                    mainLog('Task creation lock released');
                }, 1000);
            });
            
    } catch (error) {
        // Always release the lock on errors
        window.TASK_LOCK.release();
        mainLog('Error in task creation:', error);
    }
}

// Make createTask function available globally with prompt parameter
window.createTask = function(promptText = null) {
    // Get the prompt from the parameter or find it
    const promptInput = document.getElementById('prompt-input');
    const prompt = promptText || (promptInput?.value?.trim() || '');
    
    if (!prompt) {
        mainLog('Empty prompt, not creating task');
        return Promise.reject('Empty prompt');
    }
    
    // Close any existing event source
    if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
    }
    
    // Ensure we have the auth token
    const token = localStorage.getItem('auth_token');
    if (!token) {
        mainLog('No auth token found, redirecting to login');
        window.location.href = '/login';
        return Promise.reject('No auth token');
    }
    
    // Update UI to show loading state
    const container = document.getElementById('task-container');
    if (container) {
        container.innerHTML = '<div class="loading">Initializing task...</div>';
    }
    
    // Make the API request with auth token
    mainLog('Sending task creation request');
    return fetch('/tasks', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ prompt })
    })
    .then(response => {
        if (response.status === 401) {
            // Unauthorized, token invalid
            mainLog('Unauthorized, redirecting to login');
            window.location.href = '/login?session_expired=true';
            return null;
        }
        return response.json();
    })
    .then(data => {
        if (data) {
            mainLog('Task created successfully', data);
            setupSSE(data.task_id);
            return data;
        }
        return null;
    })
    .catch(error => {
        mainLog('Error creating task', error);
        if (container) {
            container.innerHTML = `<div class="error">Error creating task: ${error.message || 'Unknown error'}</div>`;
        }
        return Promise.reject(error);
    });
};

// Helper function to safely parse MySQL/table output from tool results
function extractToolVisualization(content) {
    if (!content) return null;
    
    try {
        mainLog('Attempting to extract visualization from:', content);
        
        // Try different extraction methods
        
        // Method 1: Direct JSON pattern in tool output
        const jsonMatch = content.match(/Observed output of cmd.*?executed:\s*(\{.*?\})/s);
        if (jsonMatch) {
            const jsonStr = jsonMatch[1];
            mainLog('Found JSON in tool output:', jsonStr);
            try {
                const toolData = JSON.parse(jsonStr);
                
                // Check if this has visualization data
                if (toolData.output) {
                    // For MySQL tables or other tabular data
                    if (toolData.visualization_type === 'table' || 
                       (toolData.output.includes('+-') && toolData.output.includes('-+') && toolData.output.includes('|'))) {
                        
                        mainLog('Detected MySQL table format in output');
                        const markdownTable = convertMySQLOutputToMarkdown(toolData.output);
                        if (markdownTable) {
                            const parsedTable = parseMarkdownTable(markdownTable);
                            if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                                mainLog('Successfully parsed table data', parsedTable);
                                return {
                                    type: 'table',
                                    title: 'Query Result',
                                    content: parsedTable,
                                    id: toolData.id || null,
                                    originalMarkdown: markdownTable,
                                    toolOutput: toolData.output
                                };
                            }
                        }
                    }
                }
            } catch (e) {
                mainLog('Error parsing JSON from tool output:', e);
            }
        }
        
        // Method 2: Look for MySQL output format directly
        if (content.includes('+---') && content.includes('|')) {
            const tableLines = content.split('\n').filter(line => 
                line.includes('|') || line.includes('+---'));
            
            if (tableLines.length > 2) {
                const tableText = tableLines.join('\n');
                mainLog('Found MySQL table format directly:', tableText);
                
                const markdownTable = convertMySQLOutputToMarkdown(tableText);
                if (markdownTable) {
                    const parsedTable = parseMarkdownTable(markdownTable);
                    if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                        return {
                            type: 'table',
                            title: 'Query Result',
                            content: parsedTable,
                            id: `direct-table-${Date.now()}`,
                            originalMarkdown: markdownTable,
                            toolOutput: tableText
                        };
                    }
                }
            }
        }
        
        // Method 3: Look for Step content with mysql_rw execution
        const stepMatch = content.match(/Step \d+: Observed output of cmd `mysql_rw` executed:\s*(\{.*?\})/s);
        if (stepMatch) {
            const jsonStr = stepMatch[1];
            mainLog('Found mysql_rw output in step content:', jsonStr);
            
            try {
                const toolData = JSON.parse(jsonStr);
                if (toolData.output && (toolData.output.includes('+-') || toolData.output.includes('|'))) {
                    const markdownTable = convertMySQLOutputToMarkdown(toolData.output);
                    if (markdownTable) {
                        const parsedTable = parseMarkdownTable(markdownTable);
                        if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                            mainLog('Successfully parsed step table data', parsedTable);
                            return {
                                type: 'table',
                                title: 'Query Result',
                                content: parsedTable,
                                id: toolData.id || `step-table-${Date.now()}`,
                                originalMarkdown: markdownTable,
                                toolOutput: toolData.output
                            };
                        }
                    }
                }
            } catch (e) {
                mainLog('Error parsing JSON from step output:', e);
            }
        }
    } catch (error) {
        mainLog('Error extracting tool visualization:', error);
    }
    
    return null;
}

// Separate function to set up event listeners to avoid code duplication
function setupEventListeners(eventSource, stepContainer, container) {
    // Initialize the log counter for this task
    let lastId = 0;
    // Store step numbers to avoid duplicates
    let seenStepNumbers = new Set();
    
    // Helper function to safely parse JSON
    function safeJsonParse(data) {
        try {
            if (!data || data === 'undefined' || data === '') {
                mainLog('Empty data received in safeJsonParse');
                return { content: 'Empty response received', id: ++lastId, timestamp: new Date().toISOString() };
            }
            return JSON.parse(data);
        } catch (e) {
            mainLog('JSON Parse error:', e, 'Data:', data);
            return { content: 'Error parsing response data', id: ++lastId, timestamp: new Date().toISOString() };
        }
    }

    // Flag to track if we've displayed error messages about connection issues
    let connectionIssueDisplayed = false;
    
    // Periodic connection check
    let connectionCheckInterval = setInterval(() => {
        if (eventSource.readyState === EventSource.CLOSED) {
            mainLog('Connection check: Detected closed EventSource');
            clearInterval(connectionCheckInterval);
            
            // Only show error once if not already handled
            if (!connectionIssueDisplayed) {
                connectionIssueDisplayed = true;
                const disconnectElement = createStepElement('warn', 'Connection closed unexpectedly. The task may have completed or encountered an error.', new Date().toLocaleTimeString());
                stepContainer.appendChild(disconnectElement);
                autoScroll(container);
            }
        }
    }, 5000);

    // Handle different event types
    eventSource.addEventListener('connected', function(event) {
        debugMsgCounter.connected++;
        mainLog(`[DEBUG #${debugMsgCounter.connected}] Received connected event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        // Only process connected event once per task
        if (connectionStatus.connected) {
            mainLog('Already connected, ignoring duplicate connected event', { sourceCount: debugMsgCounter.connected });
            return;
        }
        
        connectionStatus.connected = true;
        
        // Remove any connecting messages
        const connectingMessages = stepContainer.querySelectorAll('[data-message-type="connecting"]');
        mainLog('Removing connecting messages', { count: connectingMessages.length });
        connectingMessages.forEach(msg => msg.remove());
        
        const data = safeJsonParse(event.data);
        const connectionElement = createStepElement('info', 'Connected to server', new Date().toLocaleTimeString());
        connectionElement.dataset.source = `connected-${debugMsgCounter.connected}`;
        stepContainer.appendChild(connectionElement);
        
        autoScroll(container);
    });
    
    eventSource.addEventListener('step', function(event) {
        debugMsgCounter.step++;
        mainLog(`[DEBUG #${debugMsgCounter.step}] Received step event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate step message with ID: ${data.id}`, { sourceCount: debugMsgCounter.step });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `step-${++lastId}-${debugMsgCounter.step}`;
            processedMessageIds.add(data.id);
        }
        
        // Check for duplicate step numbers
        const stepMatch = data.content?.match(/^(\d+)(?:\/\d+)?/);
        if (stepMatch) {
            const stepNumber = stepMatch[1];
            mainLog(`Processing step number: ${stepNumber}`, { 
                inSeenSet: seenStepNumbers.has(stepNumber),
                seenSteps: Array.from(seenStepNumbers),
                sourceCount: debugMsgCounter.step
            });
            
            if (seenStepNumbers.has(stepNumber)) {
                mainLog(`Skipping duplicate step number: ${stepNumber}`, { sourceCount: debugMsgCounter.step });
                return;
            }
            seenStepNumbers.add(stepNumber);
        }
        
        // Check if this step contains a visualization
        const visualizationData = extractVisualization(data.content);
        if (visualizationData) {
            addVisualizationItem(visualizationData);
        }
        
        const formattedContent = formatStepContent(data, 'step');
        const stepElement = createStepElement('step', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null (null means it's a duplicate we want to skip)
        if (stepElement) {
            stepElement.dataset.source = `step-${debugMsgCounter.step}`;
            stepElement.dataset.id = data.id;
            mainLog('Appending step element', { id: data.id, sourceCount: debugMsgCounter.step });
            stepContainer.appendChild(stepElement);
            autoScroll(container);
        } else {
            mainLog('Step element was null, not appending', { sourceCount: debugMsgCounter.step });
        }
    });
    
    eventSource.addEventListener('log', function(event) {
        debugMsgCounter.log++;
        mainLog(`[DEBUG #${debugMsgCounter.log}] Received log event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate log message with ID: ${data.id}`, { sourceCount: debugMsgCounter.log });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `log-${++lastId}-${debugMsgCounter.log}`;
            processedMessageIds.add(data.id);
        }
        
        const formattedContent = formatStepContent(data, 'log');
        const logElement = createStepElement('log', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (logElement) {
            logElement.dataset.source = `log-${debugMsgCounter.log}`;
            logElement.dataset.id = data.id;
            mainLog('Appending log element', { id: data.id, sourceCount: debugMsgCounter.log });
            stepContainer.appendChild(logElement);
            autoScroll(container);
        } else {
            mainLog('Log element was null, not appending', { sourceCount: debugMsgCounter.log });
        }
    });
    
    eventSource.addEventListener('think', function(event) {
        debugMsgCounter.think++;
        mainLog(`[DEBUG #${debugMsgCounter.think}] Received think event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate think message with ID: ${data.id}`, { sourceCount: debugMsgCounter.think });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `think-${++lastId}-${debugMsgCounter.think}`;
            processedMessageIds.add(data.id);
        }
        
        const formattedContent = formatStepContent(data, 'think');
        const thinkElement = createStepElement('think', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (thinkElement) {
            thinkElement.dataset.source = `think-${debugMsgCounter.think}`;
            thinkElement.dataset.id = data.id;
            mainLog('Appending think element', { id: data.id, sourceCount: debugMsgCounter.think });
            stepContainer.appendChild(thinkElement);
            autoScroll(container);
        } else {
            mainLog('Think element was null, not appending', { sourceCount: debugMsgCounter.think });
        }
    });
    
    eventSource.addEventListener('tool', function(event) {
        debugMsgCounter.tool++;
        mainLog(`[DEBUG #${debugMsgCounter.tool}] Received tool event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate tool message with ID: ${data.id}`, { sourceCount: debugMsgCounter.tool });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `tool-${++lastId}-${debugMsgCounter.tool}`;
            processedMessageIds.add(data.id);
        }
        
        // Check for MySQL result outputs specifically
        let visualizationData = null;
        
        try {
            // Try to extract the tool output for visualization
            if (data.content && typeof data.content === 'string') {
                // Check for tool results - especially look for mysql_rw tool format
                // This regex captures both typical output and visualization_type marker added by server
                const jsonMatch = data.content.match(/\{.*?"output":\s*"(.*?)"(?:.*?"visualization_type":\s*"(.*?)")?.*?\}/s);
                
                if (jsonMatch) {
                    const outputContent = jsonMatch[1]?.replace(/\\n/g, '\n') || '';
                    const visualType = jsonMatch[2] || '';
                    
                    // If it's a MySQL output table (either marked by visualization_type or detected)
                    if (visualType === 'table' || (outputContent.includes('+-') && outputContent.includes('-+'))) {
                        mainLog('Found MySQL table output', outputContent);
                        const markdownTable = convertMySQLOutputToMarkdown(outputContent);
                        
                        if (markdownTable) {
                            const parsedTable = parseMarkdownTable(markdownTable);
                            if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                                visualizationData = {
                                    type: 'table',
                                    title: 'MySQL Query Result',
                                    content: parsedTable,
                                    originalMarkdown: markdownTable,
                                    cleanedContent: data.content
                                };
                            }
                        }
                    }
                }
            }
        } catch (e) {
            mainLog('Error processing tool output for visualization:', e);
        }
        
        // If no specific visualization was found, try general extraction
        if (!visualizationData) {
            visualizationData = extractVisualization(data.content);
        }
        
        // Add visualization if found
        if (visualizationData) {
            mainLog('Adding visualization from tool output', visualizationData);
            addVisualizationItem(visualizationData);
            // Force render the visualization immediately
            renderVisualizationItems();
        }
        
        const formattedContent = formatStepContent(data, 'tool');
        const toolElement = createStepElement('tool', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (toolElement) {
            toolElement.dataset.source = `tool-${debugMsgCounter.tool}`;
            toolElement.dataset.id = data.id;
            mainLog('Appending tool element', { id: data.id, sourceCount: debugMsgCounter.tool });
            stepContainer.appendChild(toolElement);
            autoScroll(container);
        } else {
            mainLog('Tool element was null, not appending', { sourceCount: debugMsgCounter.tool });
        }
    });
    
    eventSource.addEventListener('result', function(event) {
        debugMsgCounter.result++;
        mainLog(`[DEBUG #${debugMsgCounter.result}] Received result event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate result message with ID: ${data.id}`, { sourceCount: debugMsgCounter.result });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `result-${++lastId}-${debugMsgCounter.result}`;
            processedMessageIds.add(data.id);
        }
        
        let resultContent = data.result || data.content || "Task completed";
        const formattedContent = formatStepContent({ content: resultContent, type: 'result' }, 'result');
        
        const resultElement = createStepElement('result', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (resultElement) {
            resultElement.dataset.source = `result-${debugMsgCounter.result}`;
            resultElement.dataset.id = data.id;
            mainLog('Appending result element', { id: data.id, sourceCount: debugMsgCounter.result });
            stepContainer.appendChild(resultElement);
            autoScroll(container);
            
            // Check for visualizations in the result
            try {
                // Try to extract visualization from the result
                const visualizationData = extractToolVisualization(resultContent);
                if (visualizationData) {
                    addVisualizationItem(visualizationData, data.id);
                    mainLog('Added visualization from result data', visualizationData);
                }
            } catch (e) {
                mainLog('Error processing result for visualization:', e);
            }
        } else {
            mainLog('Result element was null, not appending', { sourceCount: debugMsgCounter.result });
        }
    });
    
    eventSource.addEventListener('act', function(event) {
        debugMsgCounter.act++;
        mainLog(`[DEBUG #${debugMsgCounter.act}] Received act event from source: ${event.source?.toString() || 'unknown'}`, { data: event.data, readyState: eventSource.readyState });
        
        const data = safeJsonParse(event.data);
        
        // Skip if we've already processed this exact message
        if (data.id && processedMessageIds.has(data.id)) {
            mainLog(`Skipping duplicate act message with ID: ${data.id}`, { sourceCount: debugMsgCounter.act });
            return;
        }
        
        // Record this message as processed
        if (data.id) {
            processedMessageIds.add(data.id);
        } else {
            // Generate ID if none exists
            data.id = `act-${++lastId}-${debugMsgCounter.act}`;
            processedMessageIds.add(data.id);
        }
        
        const formattedContent = formatStepContent(data, 'act');
        const actElement = createStepElement('act', formattedContent, data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (actElement) {
            actElement.dataset.source = `act-${debugMsgCounter.act}`;
            actElement.dataset.id = data.id;
            mainLog('Appending act element', { id: data.id, sourceCount: debugMsgCounter.act });
            stepContainer.appendChild(actElement);
            autoScroll(container);
            
            // Check for visualizations in this action and add them
            const visualizationData = extractToolVisualization(formattedContent);
            if (visualizationData) {
                addVisualizationItem(visualizationData, data.id);
            }
        } else {
            mainLog('Act element was null, not appending', { sourceCount: debugMsgCounter.act });
        }
    });
    
    eventSource.addEventListener('error', function(event) {
        // Mark as having displayed a connection issue
        connectionIssueDisplayed = true;
        
        // Clear the connection check interval when we get an explicit error
        clearInterval(connectionCheckInterval);
        
        let errorMessage;
        if (event.data) {
            mainLog('Received error event with data', event.data);
            const data = safeJsonParse(event.data);
            errorMessage = formatStepContent(data, 'error');
        } else {
            // Browser-generated EventSource error (no data)
            mainLog('Received browser EventSource error (no data)');
            
            // Only show error if EventSource is actually closed
            if (eventSource.readyState === EventSource.CLOSED) {
                errorMessage = 'Connection closed by server';
            } else {
                // Just a temporary network issue, don't show error
                mainLog('EventSource not closed, might be temporary network issue');
                return;
            }
        }
        
        const errorElement = createStepElement('error', errorMessage, new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (errorElement) {
            errorElement.dataset.source = 'error';
            mainLog('Appending error element', { sourceCount: debugMsgCounter.error });
            stepContainer.appendChild(errorElement);
            autoScroll(container);
        } else {
            mainLog('Error element was null, not appending', { sourceCount: debugMsgCounter.error });
        }
        
        // Close the EventSource connection on error
        if (eventSource) {
            mainLog('Closing EventSource connection due to error');
            eventSource.close();
            currentEventSource = null;
        }
    });
    
    eventSource.addEventListener('complete', function(event) {
        mainLog('Received complete event', event.data);
        
        // Clear the connection check interval
        clearInterval(connectionCheckInterval);
        
        // Mark as having displayed a connection message
        connectionIssueDisplayed = true;
        
        const data = safeJsonParse(event.data);
        const completeElement = createStepElement('success', formatStepContent(data, 'complete'), data.timestamp || new Date().toLocaleTimeString());
        
        // Only append if the element is not null
        if (completeElement) {
            completeElement.dataset.source = 'complete';
            mainLog('Appending complete element', { sourceCount: debugMsgCounter.complete });
            stepContainer.appendChild(completeElement);
            autoScroll(container);
        } else {
            mainLog('Complete element was null, not appending', { sourceCount: debugMsgCounter.complete });
        }
        
        // Close the EventSource connection
        if (eventSource) {
            mainLog('Closing EventSource connection after completion');
            eventSource.close();
            currentEventSource = null;
        }
    });

    eventSource.addEventListener('ping', function() {
        // Just to keep the connection alive, no UI update needed
        mainLog('Received ping event');
    });
    
    // Handle browser-level close event
    eventSource.addEventListener('close', function() {
        mainLog('EventSource received close event');
        
        // Clear the connection check interval
        clearInterval(connectionCheckInterval);
        
        if (!connectionIssueDisplayed) {
            connectionIssueDisplayed = true;
            const closedElement = createStepElement('info', 'Connection closed by server', new Date().toLocaleTimeString());
            
            // Only append if the element is not null
            if (closedElement) {
                closedElement.dataset.source = 'close';
                mainLog('Appending close element', { sourceCount: debugMsgCounter.close });
                stepContainer.appendChild(closedElement);
                autoScroll(container);
            } else {
                mainLog('Close element was null, not appending', { sourceCount: debugMsgCounter.close });
            }
        }
        
        // Ensure connection is fully closed
        if (eventSource) {
            eventSource.close();
            currentEventSource = null;
        }
    });
    
    // Return the interval ID for cleanup
    return connectionCheckInterval;
}

async function setupSSE(taskId) {
    if (!taskId) {
        mainLog('Invalid task ID provided to setupSSE:', taskId);
        return;
    }

    // Clean up existing connection if any
    if (currentEventSource) {
        mainLog('Closing existing EventSource connection');
        currentEventSource.close();
        currentEventSource = null;
    }

    // Reset connection status for the new task
    connectionStatus = {
        connecting: false,
        connected: false
    };
    processedMessageIds.clear();
    outputItems = [];

    // Wait for token validation before connecting
    const isValid = await window.checkAndRefreshToken();
    if (!isValid) {
        mainLog('Token validation failed, cannot setup EventSource');
        const container = document.getElementById('task-container');
        container.innerHTML = '<div class="error">Authentication error. Please <a href="/login">login</a> again.</div>';
        return;
    }

    // Get auth token for the EventSource connection
    const token = localStorage.getItem('auth_token');
    if (!token) {
        mainLog('No auth token found for EventSource connection');
        window.location.href = '/login';
        return;
    }

    // Create EventSource with token in URL for authentication
    const eventSourceUrl = `/tasks/${taskId}/events?token=${encodeURIComponent(token)}`;
    
    // Show connecting message
    const container = document.getElementById('task-container');
    const stepContainer = ensureStepContainer(container);

    // Only show connecting message if not already displayed
    if (!connectionStatus.connecting) {
        connectionStatus.connecting = true;
        const connectingElement = createStepElement('info', 'Connecting to task...', new Date().toLocaleTimeString());
        connectingElement.dataset.messageType = 'connecting';
        stepContainer.appendChild(connectingElement);
        autoScroll(container);
    }
    
    // Set connection attempt counter
    let connectionAttempts = 0;
    const maxConnectionAttempts = 3;
    let connectionCheckInterval = null;
    
    function connectEventSource() {
        try {
            mainLog('Creating EventSource connection', { url: eventSourceUrl, attempt: connectionAttempts + 1 });
            currentEventSource = new EventSource(eventSourceUrl);
            
            currentEventSource.onopen = function() {
                mainLog(`Connected to event stream for task ${taskId}`);
                connectionAttempts = 0; // Reset counter on successful connection
            };
            
            currentEventSource.onerror = function(error) {
                mainLog('EventSource error:', error);
                
                // Handle connection closed
                if (currentEventSource && currentEventSource.readyState === EventSource.CLOSED) {
                    mainLog('Connection was closed');
                    
                    // Try to reconnect if we haven't exceeded max attempts
                    if (connectionAttempts < maxConnectionAttempts) {
                        connectionAttempts++;
                        
                        // Show reconnecting message
                        const reconnectElement = createStepElement('warn', `Connection lost. Reconnecting (attempt ${connectionAttempts}/${maxConnectionAttempts})...`, new Date().toLocaleTimeString());
                        stepContainer.appendChild(reconnectElement);
                        autoScroll(container);
                        
                        // Wait before reconnecting
                        setTimeout(() => {
                            if (currentEventSource) {
                                currentEventSource.close();
                                currentEventSource = null;
                            }
                            connectEventSource();
                        }, 2000); // 2 second delay before retry
                        
                        return;
                    }
                    
                    // Max attempts reached, show error
                    const errorElement = createStepElement('error', 'Failed to connect to server after multiple attempts. Please refresh the page and try again.', new Date().toLocaleTimeString());
                    stepContainer.appendChild(errorElement);
                    autoScroll(container);
                }
                
                // Close connection on error
                if (currentEventSource && connectionAttempts >= maxConnectionAttempts) {
                    currentEventSource.close();
                    currentEventSource = null;
                    
                    // Also clear the interval if it exists
                    if (connectionCheckInterval) {
                        clearInterval(connectionCheckInterval);
                        connectionCheckInterval = null;
                    }
                }
            };
            
            // Set up event listeners and store the interval ID
            connectionCheckInterval = setupEventListeners(currentEventSource, stepContainer, container);
        } catch (error) {
            mainLog('Error creating EventSource:', error);
            const errorElement = createStepElement('error', 'Error connecting to event stream: ' + error.message, new Date().toLocaleTimeString());
            stepContainer.appendChild(errorElement);
            autoScroll(container);
            
            // Clean up interval if there's an error creating the EventSource
            if (connectionCheckInterval) {
                clearInterval(connectionCheckInterval);
                connectionCheckInterval = null;
            }
        }
    }
    
    // Initial connection
    connectEventSource();
    
    // Return a cleanup function (for future use with reactive frameworks)
    return () => {
        mainLog('Cleaning up EventSource connection');
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
            connectionCheckInterval = null;
        }
        if (currentEventSource) {
            currentEventSource.close();
            currentEventSource = null;
        }
    };
}

function checkConfigStatus() {
    fetch('/config/status')
    .then(response => response.json())
    .then(data => {
        const inputContainer = document.getElementById('input-container');
        if (data.status === 'missing') {
            showConfigModal(data.example_config);
            inputContainer.classList.add('disabled');
        } else if (data.status === 'no_example') {
            alert('Error: Missing configuration example file! Please ensure that the config/config.example.toml file exists.');
            inputContainer.classList.add('disabled');
        } else {
            inputContainer.classList.remove('disabled');
        }
    })
    .catch(error => {
        console.error('Configuration check failed:', error);
        document.getElementById('input-container').classList.add('disabled');
    });
}

// Display configuration pop-up and fill in sample configurations
function showConfigModal(config) {
    const configModal = document.getElementById('config-modal');
    if (!configModal) return;

    configModal.classList.add('active');

    if (config) {
        fillConfigForm(config);
    }

    const closeBtn = configModal.querySelector('.close-modal');
    const cancelBtn = document.getElementById('cancel-config-btn');

    function closeConfigModal() {
        configModal.classList.remove('active');
        document.getElementById('config-error').textContent = '';
        document.querySelectorAll('.form-group.error').forEach(group => {
            group.classList.remove('error');
        });
    }

    if (closeBtn) {
        closeBtn.onclick = closeConfigModal;
    }

    if (cancelBtn) {
        cancelBtn.onclick = closeConfigModal;
    }

    const saveButton = document.getElementById('save-config-btn');
    if (saveButton) {
        saveButton.onclick = saveConfig;
    }
}

// Use example configuration to fill in the form
function fillConfigForm(exampleConfig) {
    if (exampleConfig.llm) {
        const llm = exampleConfig.llm;

        setInputValue('llm-model', llm.model);
        setInputValue('llm-base-url', llm.base_url);
        setInputValue('llm-api-key', llm.api_key);

        exampleApiKey = llm.api_key || '';

        setInputValue('llm-max-tokens', llm.max_tokens);
        setInputValue('llm-temperature', llm.temperature);
    }

    if (exampleConfig.server) {
        setInputValue('server-host', exampleConfig.server.host);
        setInputValue('server-port', exampleConfig.server.port);
    }
}

function setInputValue(id, value) {
    const input = document.getElementById(id);
    if (input && value !== undefined) {
        input.value = value;
    }
}

function saveConfig() {
    const configData = collectFormData();

    const requiredFields = [
        { id: 'llm-model', name: 'Model Name' },
        { id: 'llm-base-url', name: 'API Base URL' },
        { id: 'llm-api-key', name: 'API Key' },
        { id: 'server-host', name: 'Server Host' },
        { id: 'server-port', name: 'Server Port' }
    ];

    let missingFields = [];
    requiredFields.forEach(field => {
        if (!document.getElementById(field.id).value.trim()) {
            missingFields.push(field.name);
        }
    });

    if (missingFields.length > 0) {
        document.getElementById('config-error').textContent =
            `Please fill in the necessary configuration information: ${missingFields.join(', ')}`;
        return;
    }

    // Check if the API key is the same as the example configuration
    const apiKey = document.getElementById('llm-api-key').value.trim();
    if (apiKey === exampleApiKey && exampleApiKey.includes('sk-')) {
        document.getElementById('config-error').textContent =
            `Please enter your own API key`;
        document.getElementById('llm-api-key').parentElement.classList.add('error');
        return;
    } else {
        document.getElementById('llm-api-key').parentElement.classList.remove('error');
    }

    fetch('/config/save', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(configData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            document.getElementById('config-modal').classList.remove('active');
            document.getElementById('input-container').classList.remove('disabled');
            alert('Configuration saved successfully! The application will use the new configuration on next startup.');
            window.location.reload();
        } else {
            document.getElementById('config-error').textContent =
                `Save failed: ${data.message}`;
        }
    })
    .catch(error => {
        document.getElementById('config-error').textContent =
            `Request error: ${error.message}`;
    });
}

// Collect form data
function collectFormData() {
    const configData = {
        llm: {
            model: document.getElementById('llm-model').value,
            base_url: document.getElementById('llm-base-url').value,
            api_key: document.getElementById('llm-api-key').value
        },
        server: {
            host: document.getElementById('server-host').value,
            port: parseInt(document.getElementById('server-port').value || '5172')
        }
    };

    const maxTokens = document.getElementById('llm-max-tokens').value;
    if (maxTokens) {
        configData.llm.max_tokens = parseInt(maxTokens);
    }

    const temperature = document.getElementById('llm-temperature').value;
    if (temperature) {
        configData.llm.temperature = parseFloat(temperature);
    }

    return configData;
}

function extractVisualization(content) {
    if (!content) return null;
    
    // Check for markdown tables
    const tableRegex = /\|[\s\S]*?\|\n[\s\S]*?\|[\s\S]*?(\n\n|\n$|$)/g;
    const tableMatches = content.match(tableRegex);
    
    if (tableMatches && tableMatches.length > 0) {
        // Parse the first table found
        const tableData = parseMarkdownTable(tableMatches[0]);
        if (tableData && tableData.headers && tableData.rows && tableData.rows.length > 0) {
            // Remove the table from the content for chat display
            const cleanedContent = content.replace(tableMatches[0], '');
            
            return {
                type: 'table',
                title: 'Generated Table',
                content: tableData,
                originalMarkdown: tableMatches[0],
                cleanedContent: cleanedContent
            };
        }
    }
    
    // TODO: Add support for other visualizations like charts, images, etc.
    
    return null;
}

// Parse a markdown table into structured data
function parseMarkdownTable(markdownTable) {
    if (!markdownTable) return null;
    
    const lines = markdownTable.trim().split('\n');
    if (lines.length < 3) return null; // Need at least header, separator, and one data row
    
    // Parse headers (first row)
    const headerLine = lines[0];
    const headers = headerLine.split('|')
        .map(h => h.trim())
        .filter(h => h.length > 0);
    
    // Skip the separator line (line[1])
    
    // Parse data rows
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || !line.includes('|')) continue;
        
        const cells = line.split('|')
            .map(c => c.trim())
            .filter((c, idx) => idx > 0 && idx <= headers.length);
        
        if (cells.length > 0) {
            const row = {};
            headers.forEach((header, index) => {
                row[header] = cells[index] || '';
            });
            rows.push(row);
        }
    }
    
    return { headers, rows };
}

// Add a visualization item to the output workspace
function addVisualizationItem(data, sourceId = null) {
    if (!data) return;
    
    mainLog('Adding visualization item', data);
    
    // Get the visualization panel
    const workspace = document.getElementById('output-workspace');
    if (!workspace) return;
    
    // Remove "empty" message if it exists
    const emptyMsg = workspace.querySelector('.empty-output');
    if (emptyMsg) emptyMsg.style.display = 'none';
    
    // Create a new visualization item container
    const item = document.createElement('div');
    item.className = 'visualization-item';
    item.dataset.source = data.id || sourceId || `vis-${Date.now()}`;
    
    // Add the appropriate header
    const header = document.createElement('div');
    header.className = 'visualization-header';
    header.innerHTML = `<h3>${data.title || 'Output'}</h3>`;
    item.appendChild(header);
    
    // Create content based on visualization type
    const content = document.createElement('div');
    content.className = 'visualization-content';
    
    if (data.type === 'table' && data.content) {
        // Create table element
        const table = document.createElement('table');
        table.className = 'data-table';
        
        // Add table headers
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        data.content.headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Add table rows
        const tbody = document.createElement('tbody');
        data.content.rows.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        
        content.appendChild(table);
    } else {
        // Default to pre-formatted text for unknown types
        content.innerHTML = `<pre>${JSON.stringify(data.content || data, null, 2)}</pre>`;
    }
    
    item.appendChild(content);
    
    // Add to the visualization panel
    workspace.appendChild(item);
    
    // Add to the output items array for tracking
    outputItems.push({
        id: data.id || sourceId,
        element: item,
        data: data
    });
    
    return item;
}

// Helper function to safely parse MySQL/table output from tool results
function extractToolVisualization(content) {
    if (!content) return null;
    
    try {
        // Try to extract visualization data from tool outputs
        const visualizationData = extractToolVisualization(content);
        if (visualizationData) {
            addVisualizationItem(visualizationData);
            mainLog('Added visualization from tool output', visualizationData);
        }
    } catch (e) {
        mainLog('Error processing tool output for visualization:', e);
    }
    
    return null;
}

// Create a new step element with formatting
function createStepElement(type, content, timestamp) {
    // Skip empty content
    if (!content) return null;
    
    const element = document.createElement('div');
    element.className = `step-item ${type}-item`;
    
    // For timestamps
    let formattedTime = timestamp || new Date().toLocaleTimeString();
    if (timestamp && timestamp.includes('T')) {
        try {
            formattedTime = new Date(timestamp).toLocaleTimeString();
        } catch (e) {
            // Fallback to the original timestamp if parsing fails
        }
    }
    
    let visualizationData = null;
    
    // Generate unique ID for this element if necessary
    if (!element.id) {
        element.id = `step-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    }
    
    // Special handling for action/tool outputs
    if (type === 'act') {
        // Try to extract visualization data from tool outputs
        visualizationData = extractToolVisualization(content);
        
        // If we found visualization data, add a special class to highlight this step
        if (visualizationData) {
            element.classList.add('has-visualization');
            
            // Create and add a "View in visualization panel" button
            const viewButton = document.createElement('button');
            viewButton.className = 'view-visualization-btn';
            viewButton.textContent = 'View in visualization panel';
            viewButton.onclick = function() {
                // Highlight this visualization in the panel
                const visPanel = document.getElementById('output-workspace');
                if (visPanel) {
                    // Find the matching visualization element and highlight it
                    const visId = visualizationData.id || element.id;
                    const visElement = document.querySelector(`.visualization-item[data-source="${visId}"]`);
                    if (visElement) {
                        visElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        visElement.classList.add('highlight');
                        setTimeout(() => visElement.classList.remove('highlight'), 2000);
                    }
                }
            };
            
            // Add the visualization to the output panel immediately
            addVisualizationItem(visualizationData, element.id);
        }
    }
    
    // Create timestamp span
    const timeSpan = document.createElement('span');
    timeSpan.className = 'step-timestamp';
    timeSpan.innerText = formattedTime;
    
    // Create content div with proper formatting
    const contentDiv = document.createElement('div');
    contentDiv.className = 'step-content';
    
    if (typeof content === 'object' && content !== null) {
        // Format object content as JSON
        contentDiv.innerHTML = `<pre>${JSON.stringify(content, null, 2)}</pre>`;
    } else {
        // Regular text content, apply any needed formatting
        let formatted = content;
        
        // Add special formatting if needed for this type
        if (type === 'think') {
            formatted = `<strong>Thinking:</strong> ${formatted}`;
        } else if (type === 'tool') {
            formatted = `<strong>Tool:</strong> ${formatted}`;
        } else if (type === 'act') {
            formatted = `<strong>Action:</strong> ${formatted}`;
        }
        
        // Convert any markdown-style code blocks
        formatted = formatted.replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre class="code-block"><code>$2</code></pre>');
        
        // Convert inline code
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // Convert newlines to <br> for display
        formatted = formatted.replace(/\n/g, '<br>');
        
        contentDiv.innerHTML = formatted;
    }
    
    // Append elements to the main container
    element.appendChild(timeSpan);
    element.appendChild(contentDiv);
    
    // Add the "View in visualization panel" button if we found visualization data
    if (visualizationData && type === 'act') {
        const viewButton = document.createElement('button');
        viewButton.className = 'view-visualization-btn';
        viewButton.textContent = 'View in visualization panel';
        viewButton.onclick = function() {
            const visPanel = document.getElementById('output-workspace');
            const visId = visualizationData.id || element.id;
            const visElement = document.querySelector(`.visualization-item[data-source="${visId}"]`);
            if (visElement) {
                visElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                visElement.classList.add('highlight');
                setTimeout(() => visElement.classList.remove('highlight'), 2000);
            }
        };
        contentDiv.appendChild(viewButton);
    }
    
    return element;
}

function autoScroll(element) {
    requestAnimationFrame(() => {
        element.scrollTo({
            top: element.scrollHeight,
            behavior: 'smooth'
        });
    });
    setTimeout(() => {
        element.scrollTop = element.scrollHeight;
    }, 100);
}

function getEventIcon(eventType) {
    const icons = {
        'think': '',
        'tool': '',
        'act': '',
        'result': '',
        'error': '',
        'complete': '',
        'log': '',
        'run': ''
    };
    return icons[eventType] || '';
}

function getEventLabel(eventType) {
    const labels = {
        'think': 'Thinking',
        'tool': 'Using Tool',
        'act': 'Action',
        'result': 'Result',
        'error': 'Error',
        'complete': 'Complete',
        'log': 'Log',
        'run': 'Running'
    };
    return labels[eventType] || 'Info';
}

function updateTaskStatus(task) {
    const statusBar = document.getElementById('status-bar');
    if (!statusBar) return;

    if (task.status === 'completed') {
        statusBar.innerHTML = `<span class="status-complete"> Task completed</span>`;

        if (currentEventSource) {
            currentEventSource.close();
            currentEventSource = null;
        }
    } else if (task.status === 'failed') {
        statusBar.innerHTML = `<span class="status-error"> Task failed: ${task.error || 'Unknown error'}</span>`;

        if (currentEventSource) {
            currentEventSource.close();
            currentEventSource = null;
        }
    } else {
        statusBar.innerHTML = `<span class="status-running"> Task running: ${task.status}</span>`;
    }
}

// Display full screen image
function showFullImage(imageSrc) {
    const modal = document.getElementById('image-modal');
    if (!modal) {
        const modalDiv = document.createElement('div');
        modalDiv.id = 'image-modal';
        modalDiv.className = 'image-modal';
        modalDiv.innerHTML = `
            <span class="close-modal">&times;</span>
            <img src="${imageSrc}" class="modal-content" id="full-image">
        `;
        document.body.appendChild(modalDiv);

        const closeBtn = modalDiv.querySelector('.close-modal');
        closeBtn.addEventListener('click', () => {
            modalDiv.classList.remove('active');
        });

        modalDiv.addEventListener('click', (e) => {
            if (e.target === modalDiv) {
                modalDiv.classList.remove('active');
            }
        });

        setTimeout(() => modalDiv.classList.add('active'), 10);
    } else {
        document.getElementById('full-image').src = imageSrc;
        modal.classList.add('active');
    }
}

// Simulate running Python files
function simulateRunPython(filePath) {
    let modal = document.getElementById('python-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'python-modal';
        modal.className = 'python-modal';
        modal.innerHTML = `
            <div class="python-console">
                <div class="close-modal">&times;</div>
                <div class="python-output">Loading Python file contents...</div>
            </div>
        `;
        document.body.appendChild(modal);

        const closeBtn = modal.querySelector('.close-modal');
        closeBtn.addEventListener('click', () => {
            modal.classList.remove('active');
        });
    }

    modal.classList.add('active');

    // Load Python file content
    fetch(filePath)
        .then(response => response.text())
        .then(code => {
            const outputDiv = modal.querySelector('.python-output');
            outputDiv.innerHTML = '';

            const codeElement = document.createElement('pre');
            codeElement.textContent = code;
            codeElement.style.marginBottom = '20px';
            codeElement.style.padding = '10px';
            codeElement.style.borderBottom = '1px solid #444';
            outputDiv.appendChild(codeElement);

            // Add simulation run results
            const resultElement = document.createElement('div');
            resultElement.innerHTML = `
                <div style="color: #4CAF50; margin-top: 10px; margin-bottom: 10px;">
                    > Simulated operation output:</div>
                <pre style="color: #f8f8f8;">
#This is the result of Python code simulation run
#The actual operational results may vary

# Running ${filePath.split('/').pop()}...
print("Hello from Python Simulated environment!")

# Code execution completed
</pre>
            `;
            outputDiv.appendChild(resultElement);
        })
        .catch(error => {
            console.error('Error loading Python file:', error);
            const outputDiv = modal.querySelector('.python-output');
            outputDiv.innerHTML = `Error loading file: ${error.message}`;
        });
}

function isConfigRequired() {
    return false;
}

function isAuthenticated() {
    const token = localStorage.getItem('auth_token');
    const expires = localStorage.getItem('token_expires');
    
    if (!token || !expires) {
        return false;
    }
    
    // Check if token is expired
    const now = Math.floor(Date.now() / 1000);
    if (now > parseInt(expires)) {
        // Token expired, clean up
        localStorage.removeItem('auth_token');
        localStorage.removeItem('token_expires');
        localStorage.removeItem('username');
        return false;
    }
    
    return true;
}

// Add auth token to all fetch requests
const originalFetch = window.fetch;
window.fetch = function(url, options = {}) {
    // Only add auth header for API endpoints, not for static assets
    if (typeof url === 'string' && url.startsWith('/') && !url.startsWith('/static/') && !url.includes('/auth/')) {
        const token = localStorage.getItem('auth_token');
        
        if (token) {
            options.headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
        }
    }
    return originalFetch(url, options);
};

// Function to handle 401 Unauthorized responses
function handleUnauthorizedResponse(response) {
    if (response.status === 401) {
        // Clear stored auth data
        localStorage.removeItem('auth_token');
        localStorage.removeItem('token_expires');
        localStorage.removeItem('username');
        
        // Redirect to login page
        window.location.href = '/login?session_expired=true';
        return true;
    }
    return false;
}

// Helper function to convert MySQL ASCII table output to markdown format
function convertMySQLOutputToMarkdown(mysqlOutput) {
    if (!mysqlOutput) return null;
    
    mainLog('Converting MySQL output to markdown', mysqlOutput);
    
    // Split the output into lines
    const lines = mysqlOutput.split('\n').filter(line => line.trim());
    if (lines.length < 3) return null; // Need at least header, separator, and one data row
    
    // Find the header line (it's between the first and second separator lines)
    let headerLineIndex = -1;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('+-') && lines[i].includes('-+')) {
            headerLineIndex = i + 1;
            break;
        }
    }
    
    if (headerLineIndex === -1 || headerLineIndex >= lines.length) {
        mainLog('Could not find header line in MySQL output');
        return null;
    }
    
    const headerLine = lines[headerLineIndex];
    
    // Replace MySQL table formatting with markdown formatting
    let headerCells = headerLine.split('|')
        .map(cell => cell.trim())
        .filter(cell => cell); // Remove empty cells
    
    if (headerCells.length === 0) {
        mainLog('No header cells found in MySQL output');
        return null;
    }
    
    // Create the markdown table header
    let markdownTable = '| ' + headerCells.join(' | ') + ' |\n';
    
    // Add the separator line
    markdownTable += '| ' + headerCells.map(() => '---').join(' | ') + ' |\n';
    
    // Add data rows (skip separator lines and the header)
    let inDataSection = false;
    for (let i = headerLineIndex + 1; i < lines.length; i++) {
        // Skip separator lines
        if (lines[i].includes('+-') && lines[i].includes('-+')) {
            if (!inDataSection) {
                inDataSection = true; // Start of data section
            }
            continue;
        }
        
        if (inDataSection) {
            const rowCells = lines[i].split('|')
                .map(c => c.trim())
                .filter((c, idx) => idx > 0 && idx <= headerCells.length);
            
            if (rowCells.length > 0) {
                markdownTable += '| ' + rowCells.join(' | ') + ' |\n';
            }
        }
    }
    
    mainLog('Converted MySQL output to markdown table', markdownTable);
    return markdownTable;
}

// Setup UI components with panel resize, etc.
function setupUI() {
    mainLog('Setting up UI components');
    
    // Setup user menu
    const username = localStorage.getItem('username');
    const userMenu = document.getElementById('user-menu');
    const usernameDisplay = document.getElementById('username-display');
    const userAvatar = document.getElementById('user-avatar');

    if (username && usernameDisplay) {
        usernameDisplay.textContent = username;
        
        // Create avatar with first letter of username
        if (userAvatar) {
            userAvatar.textContent = username.charAt(0).toUpperCase();
        }
        
        // Toggle user menu dropdown
        if (userMenu) {
            userMenu.addEventListener('click', function(e) {
                e.stopPropagation();
                userMenu.classList.toggle('active');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function() {
                userMenu.classList.remove('active');
            });
        }
    }
    
    // Initialize panel resize
    const chatPanel = document.getElementById('chat-panel');
    const resizeHandle = document.getElementById('panel-resize-handle');
    const contentContainer = document.querySelector('.content-container');
    
    if (chatPanel && resizeHandle && contentContainer) {
        let isResizing = false;
        let startX, startWidth;
        
        // Initialize resize handle position
        resizeHandle.style.left = `${chatPanel.offsetWidth}px`;
        
        // When user presses mouse button on the resize handle
        resizeHandle.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startWidth = chatPanel.offsetWidth;
            
            resizeHandle.classList.add('resizing');
            contentContainer.classList.add('resizing');
            
            e.preventDefault();
        });
        
        // When user moves the mouse after pressing the resize handle
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            // Calculate new width
            const containerWidth = contentContainer.offsetWidth;
            const newWidth = startWidth + (e.clientX - startX);
            
            // Apply constraints: min-width 250px, max-width 50% of container
            const minWidth = 250;
            const maxWidth = containerWidth * 0.5;
            
            let appliedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
            
            // Update chat panel width
            chatPanel.style.width = `${appliedWidth}px`;
            
            // Update resize handle position
            resizeHandle.style.left = `${appliedWidth}px`;
        });
        
        // When user releases the mouse button
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                resizeHandle.classList.remove('resizing');
                contentContainer.classList.remove('resizing');
            }
        });
    }
    
    // Event listeners for config button
    const configButton = document.getElementById('config-button');
    if (configButton) {
        configButton.addEventListener('click', () => {
            if (!isConfigRequired()) {
                showConfigModal();
            }
        });
    }
    
    // Setup language selector
    const languageSelect = document.getElementById('language-select');
    if (languageSelect) {
        languageSelect.addEventListener('change', function() {
            setLanguage(this.value);
        });
    }
    
    // Add custom styles for visualization panel
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .visualization-item {
            margin: 1rem;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .visualization-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 0.5rem;
            text-align: left;
        }
        
        .data-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .visualization-item.highlight {
            animation: highlight-pulse 2s;
        }
        
        @keyframes highlight-pulse {
            0% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(66, 133, 244, 0); }
            100% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0); }
        }
        
        .view-visualization-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.3rem 0.6rem;
            margin-top: 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .view-visualization-btn:hover {
            background-color: #3367d6;
        }
        
        .step-item.has-visualization {
            border-left: 3px solid #4285f4;
        }
    `;
    document.head.appendChild(styleElement);
}

// Helper function to safely parse MySQL/table output from tool results
function extractToolVisualization(content) {
    if (!content) return null;
    
    try {
        mainLog('Attempting to extract visualization from:', content);
        
        // Try different extraction methods
        
        // Method 1: Direct JSON pattern in tool output
        const jsonMatch = content.match(/Observed output of cmd.*?executed:\s*(\{.*?\})/s);
        if (jsonMatch) {
            const jsonStr = jsonMatch[1];
            mainLog('Found JSON in tool output:', jsonStr);
            try {
                const toolData = JSON.parse(jsonStr);
                
                // Check if this has visualization data
                if (toolData.output) {
                    // For MySQL tables or other tabular data
                    if (toolData.visualization_type === 'table' || 
                       (toolData.output.includes('+-') && toolData.output.includes('-+') && toolData.output.includes('|'))) {
                        
                        mainLog('Detected MySQL table format in output');
                        const markdownTable = convertMySQLOutputToMarkdown(toolData.output);
                        if (markdownTable) {
                            const parsedTable = parseMarkdownTable(markdownTable);
                            if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                                mainLog('Successfully parsed table data', parsedTable);
                                return {
                                    type: 'table',
                                    title: 'Query Result',
                                    content: parsedTable,
                                    id: toolData.id || null,
                                    originalMarkdown: markdownTable,
                                    toolOutput: toolData.output
                                };
                            }
                        }
                    }
                }
            } catch (e) {
                mainLog('Error parsing JSON from tool output:', e);
            }
        }
        
        // Method 2: Look for MySQL output format directly
        if (content.includes('+---') && content.includes('|')) {
            const tableLines = content.split('\n').filter(line => 
                line.includes('|') || line.includes('+---'));
            
            if (tableLines.length > 2) {
                const tableText = tableLines.join('\n');
                mainLog('Found MySQL table format directly:', tableText);
                
                const markdownTable = convertMySQLOutputToMarkdown(tableText);
                if (markdownTable) {
                    const parsedTable = parseMarkdownTable(markdownTable);
                    if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                        return {
                            type: 'table',
                            title: 'Query Result',
                            content: parsedTable,
                            id: `direct-table-${Date.now()}`,
                            originalMarkdown: markdownTable,
                            toolOutput: tableText
                        };
                    }
                }
            }
        }
        
        // Method 3: Look for Step content with mysql_rw execution
        const stepMatch = content.match(/Step \d+: Observed output of cmd `mysql_rw` executed:\s*(\{.*?\})/s);
        if (stepMatch) {
            const jsonStr = stepMatch[1];
            mainLog('Found mysql_rw output in step content:', jsonStr);
            
            try {
                const toolData = JSON.parse(jsonStr);
                if (toolData.output && (toolData.output.includes('+-') || toolData.output.includes('|'))) {
                    const markdownTable = convertMySQLOutputToMarkdown(toolData.output);
                    if (markdownTable) {
                        const parsedTable = parseMarkdownTable(markdownTable);
                        if (parsedTable && parsedTable.headers && parsedTable.rows.length > 0) {
                            mainLog('Successfully parsed step table data', parsedTable);
                            return {
                                type: 'table',
                                title: 'Query Result',
                                content: parsedTable,
                                id: toolData.id || `step-table-${Date.now()}`,
                                originalMarkdown: markdownTable,
                                toolOutput: toolData.output
                            };
                        }
                    }
                }
            } catch (e) {
                mainLog('Error parsing JSON from step output:', e);
            }
        }
    } catch (error) {
        mainLog('Error extracting tool visualization:', error);
    }
    
    return null;
}

// Convert MySQL table output to markdown format
function convertMySQLOutputToMarkdown(mysqlOutput) {
    try {
        if (!mysqlOutput) return null;
        
        // Split the MySQL output into lines
        let lines = mysqlOutput.split('\n');
        
        // Filter out empty lines and keep only rows with data or separator lines
        lines = lines.filter(line => line.trim().length > 0);
        
        if (lines.length < 3) {
            mainLog('Not enough lines for a valid table');
            return null; // Not enough lines for a valid table
        }
        
        // Initialize markdown table lines
        const markdownLines = [];
        
        // Process header line (second line, after the top border)
        const headerLine = lines.find(line => line.includes('|') && !line.includes('+-'));
        if (!headerLine) {
            mainLog('No header line found in MySQL output');
            return null;
        }
        
        // Extract headers from the header line
        const headers = headerLine.split('|')
            .map(h => h.trim())
            .filter(h => h.length > 0);
        
        if (headers.length === 0) {
            mainLog('No valid headers found');
            return null;
        }
        
        // Add headers to markdown
        markdownLines.push(`| ${headers.join(' | ')} |`);
        
        // Add separator line
        markdownLines.push(`| ${headers.map(() => '---').join(' | ')} |`);
        
        // Process data rows (all lines that have | but are not headers or separator lines)
        const dataLines = lines.filter(line => 
            line.includes('|') && 
            !line.includes('+-') && 
            line !== headerLine
        );
        
        // Add data rows to markdown
        dataLines.forEach(line => {
            const cells = line.split('|')
                .map(c => c.trim())
                .filter(c => c.length > 0);
            
            if (cells.length > 0) {
                markdownLines.push(`| ${cells.join(' | ')} |`);
            }
        });
        
        // Make sure we have at least one data row
        if (markdownLines.length < 3) {
            mainLog('No data rows found');
            return null;
        }
        
        return markdownLines.join('\n');
    } catch (error) {
        mainLog('Error converting MySQL output to markdown:', error);
        return null;
    }
}

// Parse markdown table into structured data
function parseMarkdownTable(markdownTable) {
    if (!markdownTable) return null;
    
    try {
        const lines = markdownTable.trim().split('\n');
        if (lines.length < 3) return null; // Need at least header, separator, and one data row
        
        // Parse headers (first row)
        const headerLine = lines[0];
        const headers = headerLine.split('|')
            .map(h => h.trim())
            .filter(h => h.length > 0);
        
        if (headers.length === 0) return null;
        
        // Skip the separator line (line[1])
        
        // Parse data rows
        const rows = [];
        for (let i = 2; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || !line.includes('|')) continue;
            
            const cells = line.split('|')
                .map(c => c.trim())
                .filter(c => c.length > 0);
            
            if (cells.length > 0) {
                rows.push(cells);
            }
        }
        
        return { headers, rows };
    } catch (error) {
        mainLog('Error parsing markdown table:', error);
        return null;
    }
}

// Add a visualization item to the visualization panel
function addVisualizationItem(data, sourceId = null) {
    if (!data) {
        mainLog('No visualization data to add');
        return;
    }
    
    mainLog('Adding visualization item', data);
    
    // Get the visualization panel
    const workspace = document.getElementById('output-workspace');
    if (!workspace) {
        mainLog('Visualization workspace not found');
        return;
    }
    
    // Remove "empty" message if it exists
    const emptyMsg = workspace.querySelector('.empty-output');
    if (emptyMsg) {
        emptyMsg.style.display = 'none';
    }
    
    // Create a new visualization item container
    const item = document.createElement('div');
    item.className = 'visualization-item';
    item.dataset.source = data.id || sourceId || `vis-${Date.now()}`;
    
    // Add the appropriate header
    const header = document.createElement('div');
    header.className = 'visualization-header';
    header.innerHTML = `<h3>${data.title || 'Query Result'}</h3>`;
    item.appendChild(header);
    
    // Create content based on visualization type
    const content = document.createElement('div');
    content.className = 'visualization-content';
    
    if (data.type === 'table' && data.content && data.content.headers && data.content.rows) {
        // Create table element
        const table = document.createElement('table');
        table.className = 'data-table';
        
        // Add table headers
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        data.content.headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Add table rows
        const tbody = document.createElement('tbody');
        
        data.content.rows.forEach(row => {
            const tr = document.createElement('tr');
            
            // Handle both array format and object format
            if (Array.isArray(row)) {
                // Array format
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
            } else {
                // Object format (using headers as keys)
                data.content.headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = row[header] || '';
                    tr.appendChild(td);
                });
            }
            
            tbody.appendChild(tr);
        });
        
        table.appendChild(tbody);
        content.appendChild(table);
        
        // Show debug info about the table
        mainLog('Created table visualization with:', { 
            headers: data.content.headers, 
            rowCount: data.content.rows.length 
        });
    } else {
        // Default to pre-formatted text for unknown types
        content.innerHTML = `<pre>${JSON.stringify(data.content || data, null, 2)}</pre>`;
        mainLog('Created default visualization (not a table)');
    }
    
    item.appendChild(content);
    
    // Add to the visualization panel
    workspace.appendChild(item);
    
    // Highlight the item briefly to draw attention
    setTimeout(() => {
        item.classList.add('highlight');
        setTimeout(() => {
            item.classList.remove('highlight');
        }, 2000);
    }, 100);
    
    // Add to the output items array for tracking
    outputItems.push({
        id: data.id || sourceId,
        element: item,
        data: data
    });
    
    return item;
}

function ensureStepContainer(container) {
    let stepContainer = container.querySelector('.step-container');
    if (!stepContainer) {
        container.innerHTML = '<div class="step-container"></div>';
        stepContainer = container.querySelector('.step-container');
    }
    return stepContainer;
}
